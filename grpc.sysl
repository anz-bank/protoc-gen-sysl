DependencyTemplate:
  !view start(module <: sysl.TemplateInput) -> sysl.TemplateResult:
    module -> (:
      apps = module.Apps -> <set of string> (app:
        app = buildApp(app)
      )
    )

  !view buildApp(app <: sysl.App) -> sysl.TemplateResult:
    app -> (:
      let endpoints = if app.endpoints count > 0 then writeEndpoints(app) else ""
      Data = buildAppHeader(app) + GenTypes(app) + endpoints
      Filename = app.name + ".proto"
    )

  !view buildAppHeader(app <: sysl.App) -> string:
    app -> (:
      $//   THIS IS AUTOGENERATED BY sysl   //
      $syntax = "proto3";
      $
      $option go_package = "{$app.attrs.package$}";
      $package {$app.attrs.package$};
    )

  !view writeEndpoints(app <: sysl.App) -> string:
    app -> (:
      $ {$Join(rpcImports(app.endpoints, app) flatten(.out), "\n")$}
      $service {$app.name$} {{
      $ {$Join(rpcMethods(app.endpoints, app) flatten(.out), "\n")$}
      $}}
      $ {$Join(enumToTypes(app.endpoints) flatten(.out), "\n")$}
      $ {$Join(wrapRpcParams(app.endpoints, app) flatten(.out), "\n")$}
      $ {$Join(wrapRpcResponses(app.endpoints, app) flatten(.out), "\n")$}
    )

  !view GenTypes(app <: sysl.App) -> string:
    app -> (:
      $ {$Join(GrpcMessageTypes(app.types, app.name, false) flatten(.out), "\n")$}
      $ {$Join(GrpcMessageImports(app.types, app.name) flatten(.out), "\n")$}
      $ {$Join(GrpcMessageTypes(app.alias, app.name, true) flatten(.out), "\n")$}
    )

  !view GrpcMessageTypes(types <: set of Type, app <: string, isAlias <: bool) -> sequence of string:
    types -> (type:
      out = if isAlias == false then "\n" + "message " + type.key +  " {\n" + Join(GrpcFields(type.fields, app) flatten(.out), "\n") + "\n}" else "\n" + "message " + type.key +  " {\n " + "string alias"+ type.type + " = 1;" + "\n}"
    )

  !view GrpcMessageImports(types <: set of Type, app <: string) -> set of string:
    types -> (type:
      out = GrpcImports(type.fields, app) flatten(.out) -> <set of string> (imp:
        out = imp
      )
    )

  !view GrpcFields(fields <: set of Type, app <: string) -> sequence of string:
    fields -> (field:
      out = " " + GrpcType(field, app).out + " " + Replace(field.key, "-", "", -1) + " = " + field.attrs.rpcId + ";"
    )

  !view GrpcImports(fields <: set of Type, app <: string) -> set of string:
    fields where(MatchString("google.protobuf", GrpcType(., app).out)) -> (field:
      out = "import \""+ Replace(GrpcType(field, app).out,".","/",-1)+ ".proto\";"
    )

  !view GrpcType(t <: sysl.Type, app <: string) -> string:
    t -> (:
      let typeName = if t.type ==:
        'primitive' => if t.primitive ==:
          'DECIMAL' => 'double'
          'INT' => 'int64'
          'FLOAT' => 'double'
          'STRING' => 'string'
          'STRING_8' => 'string'
          'BOOL' => 'bool'
          'DATE' => 'string'
          'DATETIME' => 'string'
        'sequence' => 'repeated ' + GrpcType(t.sequence, app).out
        else if MatchString("google-protobuf", t.type_ref) then Replace(t.type_ref,"-",".",-1) else if Contains(".",t.type_ref) then t.type_ref else t.type_ref
      out = typeName
    )

  !view rpcMethods(eps <: set of sysl.Endpoint, app <: sysl.App) -> set of string:
    eps where(MatchString("ENUM", ToUpper(.name)) == false) -> (ep:
      let returnTypes = ep.ret where(.key == "ok") -> <sequence of string>(a:
          out = a.value
      )
      let returnName = Join(returnTypes flatten(.out),"")
      let Method = Replace(Title(ToLower(ep.name)), "-", "", -1)
      let params = ep.params -> <sequence of Params> (param:
        out = GrpcType(param, app.name).out
      )
      let parameterName =  if "wrap" in app.attrs.patterns then Method + "Request" else Join(params flatten(.out),",")
      let responseName =  if "wrap" in app.attrs.patterns then Method + "Response" else returnName
      out = " rpc " + Method + "(" + parameterName + ") returns (" + responseName + ") {}"
    )

  !view wrapRpcParams(eps <: set of sysl.Endpoint, app <: sysl.App) -> set of string:
    eps where(MatchString("ENUM", ToUpper(.name)) == false) -> (ep:
      let Method = Replace(Title(ToLower(ep.name)), "-", "", -1)
      let params = ep.params -> <sequence of Params> (param:
        out = GrpcType(param, app.name).out
      )
      let parameterName = if "wrap" in app.attrs.patterns then Method + "Request" else Join(params flatten(.out),",")
      out = if "wrap" in app.attrs.patterns then wrapRpcRequestParams(ep, parameterName, app.name) else ""
    )

  !view wrapRpcResponses(eps <: set of sysl.Endpoint, app <: sysl.App) -> set of string:
    eps where(MatchString("ENUM", ToUpper(.name)) == false) -> (ep:
      let returnTypes = ep.ret where(.key == "ok") -> <sequence of string>(a:
        out = a.value
      )
      let returnName = Join(returnTypes flatten(.out),"")
      let Method = Replace(Title(ToLower(ep.name)), "-", "", -1)
      let responseName =  if "wrap" in app.attrs.patterns then Method + "Response" else returnName
      out = if "wrap" in app.attrs.patterns then wrapResponseParams(ep, returnName, responseName, app.name) else ""
    )

  !view rpcImports(eps <: set of sysl.Endpoint, app <: sysl.App) -> set of string:
    eps where(MatchString("ENUM", ToUpper(.name)) == false) -> (ep:
      let params = ep.params -> <sequence of Params> (param:
        out = if MatchString("google.protobuf", GrpcType(param, app.name).out) then "import \""+ Replace(GrpcType(param, app.name).out,".","/",-1)+ ".proto\";" else ""
      )
      let uniqueImps = params flatten (.out) -> <set of string> (uniqueImp:
        out = uniqueImp
      )
      out = Join(uniqueImps flatten(.out),"\n")
    )

  !view enumToTypes(eps <: set of sysl.Endpoint) -> set of string:
    eps where(MatchString("ENUM", ToUpper(.name)) == true) -> (ep:
      let enumTypes = ep.stmts -> <sequence of sysl.Stmt>(stmt:
        out = " " + stmt.action + ";"
      )
      let enumTokens = Split(ep.name," ")
      let tokens = enumTokens where(MatchString("ENUM", ToUpper(.)) == false) -> <sequence of string>(s:
        out = s
      )
      out = "enum " +  Join(tokens flatten(.out),"")  +  " {\n " + Join(enumTypes flatten(.out), "\n") + "\n}"
    )

  !view wrapRpcRequestParams(ep <: sysl.Endpoint, parameterName <: string, app <: string)->string:
    ep -> (:
      let param = getParams(ep, app).returnParams -> <set of Params> (p:
        let attrs = ep.attrs where(.key == p.name + "_rpcId") -> <sequence of string>(a:
           out = a.value
        )
        out = " " +p.type + " " + "req" + p.name + " = " + Join(attrs flatten(.out),"") + ";"
      )
      out = "message " + parameterName +  " {\n " + Join(param flatten(.out), "\n") + "\n}"
    )

  !view wrapResponseParams(ep <: sysl.Endpoint, returnName <: string, parameterName <: string, app <: string)->string:
    ep -> (:
        let retTokens = Split(returnName," ")
        let list = ["SEQUENCE", "OF"]
        let ret = retTokens where ((ToUpper(.) in list) == false) -> <sequence of string>(s:
          out = s
        )
        let retName = Join(ret flatten(.out),"")
        let attrs = ep.attrs where(.key == Replace(retName, ".", "", -1) + "_rpcId") -> <sequence of string>(a:
          out = a.value
        )
        let fieldType = if Split(retName,".") count > 1 then Replace(retName, ".", "", -1) else retName
        let fieldName = "res" + Replace(retName, ".", "", -1)
        let typeString = if retTokens count > 1 then "repeated " +fieldType + " " + fieldName + " = " + Join(attrs flatten(.out),"") + ";" else " " +fieldType + " " + fieldName + " = " + Join(attrs flatten(.out),"") + ";"
        out = "message " + parameterName +  "{\n " + typeString + "\n}"
    )

  !view getParams(ep <: sysl.Endpoint, app <: string) -> ReturnParams:
    ep -> (:
      let params = ep.params -> <sequence of Params> (param:
        name = Replace(param.name, "-", "", -1)
        type = GrpcType(param, app).out
      )
      returnParams = params
    )
