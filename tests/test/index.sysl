
Foo:
    @description = ""
    @package = "grpc_testing"
    @source_path = "tests/test/test.proto"
    Foobar(input <: grpc_testing.StreamingOutputCallRequest)[~grpc, ~GRPC]:
        @description = ""
        @source_path = "tests/test/test.proto"
        return ok <: grpc_testing.StreamingOutputCallResponse

TestService:
    @description =:
        | A simple service to test the various types of RPCs and experiment with
        | performance with various types of payload.
        | One empty request followed by one empty response.
        |    rpc EmptyCall(Empty) returns (Empty);
    @package = "grpc_testing"
    @source_path = "tests/test/test.proto"
    FullDuplexCall(input <: grpc_testing.StreamingOutputCallRequest)[~grpc, ~GRPC]:
        @description =:
            | A sequence of requests with each request served by the server immediately.
            | As one request could lead to multiple responses, this interface
            | demonstrates the idea of full duplexing.
        @source_path = "tests/test/test.proto"
        return ok <: grpc_testing.StreamingOutputCallResponse
    HalfDuplexCall(input <: grpc_testing.StreamingOutputCallRequest)[~grpc, ~GRPC]:
        @description =:
            | A sequence of requests followed by a sequence of responses.
            | The server buffers all the client requests and then serves them in order. A
            | stream of responses are returned to the client when the server starts with
            | first request.
        @source_path = "tests/test/test.proto"
        return ok <: grpc_testing.StreamingOutputCallResponse
    StreamingInputCall(input <: grpc_testing.StreamingInputCallRequest)[~grpc, ~GRPC]:
        @description =:
            | A sequence of requests followed by one response (streamed upload).
            | The server returns the aggregated size of client payload as the result.
        @source_path = "tests/test/test.proto"
        return ok <: grpc_testing.StreamingInputCallResponse
    StreamingOutputCall(input <: grpc_testing.StreamingOutputCallRequest)[~grpc, ~GRPC]:
        @description =:
            | One request followed by a sequence of responses (streamed download).
            | The server returns the payload with client desired type and sizes.
        @source_path = "tests/test/test.proto"
        return ok <: grpc_testing.StreamingOutputCallResponse

google_protobuf:
    @package = "google_protobuf"
    !type DescriptorProto:
        @description =:
            | Describes a message type.
        @source_path = "google/protobuf/descriptor.proto"
        enum_type <: sequence of EnumDescriptorProto
        extension <: sequence of FieldDescriptorProto
        extension_range <: sequence of DescriptorProto_ExtensionRange
        field <: sequence of FieldDescriptorProto
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        nested_type <: sequence of DescriptorProto
        oneof_decl <: sequence of OneofDescriptorProto
        options <: MessageOptions:
            @json_tag = "options"
            @rpcId = "7"
        reserved_name <: sequence of string
        reserved_range <: sequence of DescriptorProto_ReservedRange
    !type DescriptorProto_ExtensionRange:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        end <: int:
            @description =:
                | Exclusive.
            @json_tag = "end"
            @rpcId = "2"
        options <: ExtensionRangeOptions:
            @json_tag = "options"
            @rpcId = "3"
        start <: int:
            @description =:
                | Inclusive.
            @json_tag = "start"
            @rpcId = "1"
    !type DescriptorProto_ReservedRange:
        @description =:
            | Range of reserved tag numbers. Reserved tag numbers may not be used by
            | fields or extension ranges in the same message. Reserved ranges may
            | not overlap.
        @source_path = "google/protobuf/descriptor.proto"
        end <: int:
            @description =:
                | Exclusive.
            @json_tag = "end"
            @rpcId = "2"
        start <: int:
            @description =:
                | Inclusive.
            @json_tag = "start"
            @rpcId = "1"
    !type EnumDescriptorProto:
        @description =:
            | Describes an enum type.
        @source_path = "google/protobuf/descriptor.proto"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        options <: EnumOptions:
            @json_tag = "options"
            @rpcId = "3"
        reserved_name <: sequence of string
        reserved_range <: sequence of EnumDescriptorProto_EnumReservedRange
        value <: sequence of EnumValueDescriptorProto
    !type EnumDescriptorProto_EnumReservedRange:
        @description =:
            | Range of reserved numeric values. Reserved values may not be used by
            | entries in the same enum. Reserved ranges may not overlap.
            | Note that this is distinct from DescriptorProto.ReservedRange in that it
            | is inclusive such that it can appropriately represent the entire int32
            | domain.
        @source_path = "google/protobuf/descriptor.proto"
        end <: int:
            @description =:
                | Inclusive.
            @json_tag = "end"
            @rpcId = "2"
        start <: int:
            @description =:
                | Inclusive.
            @json_tag = "start"
            @rpcId = "1"
    !type EnumOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        allow_alias <: bool:
            @description =:
                | Set this option to true to allow mapping different tag names to the same
                | value.
            @json_tag = "allowAlias"
            @rpcId = "2"
        deprecated <: bool:
            @description =:
                | Is this enum deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the enum, or it will be completely ignored; in the very least, this
                | is a formalization for deprecating enums.
            @json_tag = "deprecated"
            @rpcId = "3"
        uninterpreted_option <: sequence of UninterpretedOption
    !type EnumValueDescriptorProto:
        @description =:
            | Describes a value within an enum.
        @source_path = "google/protobuf/descriptor.proto"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        number <: int:
            @json_tag = "number"
            @rpcId = "2"
        options <: EnumValueOptions:
            @json_tag = "options"
            @rpcId = "3"
    !type EnumValueOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        deprecated <: bool:
            @description =:
                | Is this enum value deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the enum value, or it will be completely ignored; in the very least,
                | this is a formalization for deprecating enum values.
            @json_tag = "deprecated"
            @rpcId = "1"
        uninterpreted_option <: sequence of UninterpretedOption
    !type ExtensionRangeOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        uninterpreted_option <: sequence of UninterpretedOption
    !type FieldDescriptorProto:
        @description =:
            | Describes a field within a message.
        @source_path = "google/protobuf/descriptor.proto"
        default_value <: string:
            @description =:
                | For numeric types, contains the original text representation of the value.
                | For booleans, "true" or "false".
                | For strings, contains the default text contents (not escaped in any way).
                | For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
                | TODO(kenton):  Base-64 encode?
            @json_tag = "defaultValue"
            @rpcId = "7"
        extendee <: string:
            @description =:
                | For extensions, this is the name of the type being extended.  It is
                | resolved in the same manner as type_name.
            @json_tag = "extendee"
            @rpcId = "2"
        json_name <: string:
            @description =:
                | JSON name of this field. The value is set by protocol compiler. If the
                | user has set a "json_name" option on this field, that option's value
                | will be used. Otherwise, it's deduced from the field's name by converting
                | it to camelCase.
            @json_tag = "jsonName"
            @rpcId = "10"
        label <: FieldDescriptorProto_Label:
            @json_tag = "label"
            @rpcId = "4"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        number <: int:
            @json_tag = "number"
            @rpcId = "3"
        oneof_index <: int:
            @description =:
                | If set, gives the index of a oneof in the containing type's oneof_decl
                | list.  This field is a member of that oneof.
            @json_tag = "oneofIndex"
            @rpcId = "9"
        options <: FieldOptions:
            @json_tag = "options"
            @rpcId = "8"
        type <: FieldDescriptorProto_Type:
            @description =:
                | If type_name is set, this need not be set.  If both this and type_name
                | are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
            @json_tag = "type"
            @rpcId = "5"
        type_name <: string:
            @description =:
                | For message and enum types, this is the name of the type.  If the name
                | starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
                | rules are used to find the type (i.e. first the nested types within this
                | message are searched, then within the parent, on up to the root
                | namespace).
            @json_tag = "typeName"
            @rpcId = "6"
    !enum FieldDescriptorProto_Label:
        LABEL_OPTIONAL: 1
        LABEL_REPEATED: 3
        LABEL_REQUIRED: 2
    !enum FieldDescriptorProto_Type:
        TYPE_BOOL: 8
        TYPE_BYTES: 12
        TYPE_DOUBLE: 1
        TYPE_ENUM: 14
        TYPE_FIXED32: 7
        TYPE_FIXED64: 6
        TYPE_FLOAT: 2
        TYPE_GROUP: 10
        TYPE_INT32: 5
        TYPE_INT64: 3
        TYPE_MESSAGE: 11
        TYPE_SFIXED32: 15
        TYPE_SFIXED64: 16
        TYPE_SINT32: 17
        TYPE_SINT64: 18
        TYPE_STRING: 9
        TYPE_UINT32: 13
        TYPE_UINT64: 4
    !type FieldOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        ctype <: FieldOptions_CType:
            @description =:
                | The ctype option instructs the C++ code generator to use a different
                | representation of the field than it normally would.  See the specific
                | options below.  This option is not yet implemented in the open source
                | release -- sorry, we'll try to include it in a future version!
            @json_tag = "ctype"
            @rpcId = "1"
        deprecated <: bool:
            @description =:
                | Is this field deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for accessors, or it will be completely ignored; in the very least, this
                | is a formalization for deprecating fields.
            @json_tag = "deprecated"
            @rpcId = "3"
        jstype <: FieldOptions_JSType:
            @description =:
                | The jstype option determines the JavaScript type used for values of the
                | field.  The option is permitted only for 64 bit integral and fixed types
                | (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
                | is represented as JavaScript string, which avoids loss of precision that
                | can happen when a large value is converted to a floating point JavaScript.
                | Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
                | use the JavaScript "number" type.  The behavior of the default option
                | JS_NORMAL is implementation dependent.
                | This option is an enum to permit additional types to be added, e.g.
                | goog.math.Integer.
            @json_tag = "jstype"
            @rpcId = "6"
        lazy <: bool:
            @description =:
                | Should this field be parsed lazily?  Lazy applies only to message-type
                | fields.  It means that when the outer message is initially parsed, the
                | inner message's contents will not be parsed but instead stored in encoded
                | form.  The inner message will actually be parsed when it is first accessed.
                | This is only a hint.  Implementations are free to choose whether to use
                | eager or lazy parsing regardless of the value of this option.  However,
                | setting this option true suggests that the protocol author believes that
                | using lazy parsing on this field is worth the additional bookkeeping
                | overhead typically needed to implement it.
                | This option does not affect the public interface of any generated code;
                | all method signatures remain the same.  Furthermore, thread-safety of the
                | interface is not affected by this option; const methods remain safe to
                | call from multiple threads concurrently, while non-const methods continue
                | to require exclusive access.
                | Note that implementations may choose not to check required fields within
                | a lazy sub-message.  That is, calling IsInitialized() on the outer message
                | may return true even if the inner message has missing required fields.
                | This is necessary because otherwise the inner message would have to be
                | parsed in order to perform the check, defeating the purpose of lazy
                | parsing.  An implementation which chooses not to check required fields
                | must be consistent about it.  That is, for any particular sub-message, the
                | implementation must either *always* check its required fields, or *never*
                | check its required fields, regardless of whether or not the message has
                | been parsed.
            @json_tag = "lazy"
            @rpcId = "5"
        packed <: bool:
            @description =:
                | The packed option can be enabled for repeated primitive fields to enable
                | a more efficient representation on the wire. Rather than repeatedly
                | writing the tag and type for each element, the entire array is encoded as
                | a single length-delimited blob. In proto3, only explicit setting it to
                | false will avoid using packed encoding.
            @json_tag = "packed"
            @rpcId = "2"
        uninterpreted_option <: sequence of UninterpretedOption
        weak <: bool:
            @description =:
                | For Google-internal migration only. Do not use.
            @json_tag = "weak"
            @rpcId = "10"
    !enum FieldOptions_CType:
        CORD: 1
        STRING_: 0
        STRING_PIECE: 2
    !enum FieldOptions_JSType:
        JS_NORMAL: 0
        JS_NUMBER: 2
        JS_STRING: 1
    !type FileDescriptorProto:
        @description =:
            | Describes a complete .proto file.
        @source_path = "google/protobuf/descriptor.proto"
        dependency <: sequence of string
        enum_type <: sequence of EnumDescriptorProto
        extension <: sequence of FieldDescriptorProto
        message_type <: sequence of DescriptorProto
        name <: string:
            @description =:
                | file name, relative to root of source tree
            @json_tag = "name"
            @rpcId = "1"
        options <: FileOptions:
            @json_tag = "options"
            @rpcId = "8"
        package <: string:
            @description =:
                | e.g. "foo", "foo.bar", etc.
            @json_tag = "package"
            @rpcId = "2"
        public_dependency <: sequence of int
        service <: sequence of ServiceDescriptorProto
        source_code_info <: SourceCodeInfo:
            @description =:
                | This field contains optional information about the original source code.
                | You may safely remove this entire field without harming runtime
                | functionality of the descriptors -- the information is needed only by
                | development tools.
            @json_tag = "sourceCodeInfo"
            @rpcId = "9"
        syntax <: string:
            @description =:
                | The syntax of the proto file.
                | The supported values are "proto2" and "proto3".
            @json_tag = "syntax"
            @rpcId = "12"
        weak_dependency <: sequence of int
    !type FileDescriptorSet:
        @description =:
            | The protocol compiler can output a FileDescriptorSet containing the .proto
            | files it parses.
        @source_path = "google/protobuf/descriptor.proto"
        file <: sequence of FileDescriptorProto
    !type FileOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        cc_enable_arenas <: bool:
            @description =:
                | Enables the use of arenas for the proto messages in this file. This applies
                | only to generated classes for C++.
            @json_tag = "ccEnableArenas"
            @rpcId = "31"
        cc_generic_services <: bool:
            @description =:
                | Should generic services be generated in each language?  "Generic" services
                | are not specific to any particular RPC system.  They are generated by the
                | main code generators in each language (without additional plugins).
                | Generic services were the only kind of service generation supported by
                | early versions of google.protobuf.
                | Generic services are now considered deprecated in favor of using plugins
                | that generate code specific to your particular RPC system.  Therefore,
                | these default to false.  Old code which depends on generic services should
                | explicitly set them to true.
            @json_tag = "ccGenericServices"
            @rpcId = "16"
        csharp_namespace <: string:
            @description =:
                | Namespace for generated classes; defaults to the package.
            @json_tag = "csharpNamespace"
            @rpcId = "37"
        deprecated <: bool:
            @description =:
                | Is this file deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for everything in the file, or it will be completely ignored; in the very
                | least, this is a formalization for deprecating files.
            @json_tag = "deprecated"
            @rpcId = "23"
        go_package <: string:
            @description =:
                | Sets the Go package where structs generated from this .proto will be
                | placed. If omitted, the Go package will be derived from the following:
                |   - The basename of the package import path, if provided.
                |   - Otherwise, the package statement in the .proto file, if present.
                |   - Otherwise, the basename of the .proto file, without extension.
            @json_tag = "goPackage"
            @rpcId = "11"
        java_generate_equals_and_hash <: bool:
            @description =:
                | This option does nothing.
            @json_tag = "javaGenerateEqualsAndHash"
            @rpcId = "20"
        java_generic_services <: bool:
            @json_tag = "javaGenericServices"
            @rpcId = "17"
        java_multiple_files <: bool:
            @description =:
                | If set true, then the Java code generator will generate a separate .java
                | file for each top-level message, enum, and service defined in the .proto
                | file.  Thus, these types will *not* be nested inside the outer class
                | named by java_outer_classname.  However, the outer class will still be
                | generated to contain the file's getDescriptor() method as well as any
                | top-level extensions defined in the file.
            @json_tag = "javaMultipleFiles"
            @rpcId = "10"
        java_outer_classname <: string:
            @description =:
                | If set, all the classes from the .proto file are wrapped in a single
                | outer class with the given name.  This applies to both Proto1
                | (equivalent to the old "--one_java_file" option) and Proto2 (where
                | a .proto always translates to a single class, but you may want to
                | explicitly choose the class name).
            @json_tag = "javaOuterClassname"
            @rpcId = "8"
        java_package <: string:
            @description =:
                | Sets the Java package where classes generated from this .proto will be
                | placed.  By default, the proto package is used, but this is often
                | inappropriate because proto packages do not normally start with backwards
                | domain names.
            @json_tag = "javaPackage"
            @rpcId = "1"
        java_string_check_utf8 <: bool:
            @description =:
                | If set true, then the Java2 code generator will generate code that
                | throws an exception whenever an attempt is made to assign a non-UTF-8
                | byte sequence to a string field.
                | Message reflection will do the same.
                | However, an extension field still accepts non-UTF-8 byte sequences.
                | This option has no effect on when used with the lite runtime.
            @json_tag = "javaStringCheckUtf8"
            @rpcId = "27"
        objc_class_prefix <: string:
            @description =:
                | Sets the objective c class prefix which is prepended to all objective c
                | generated classes from this .proto. There is no default.
            @json_tag = "objcClassPrefix"
            @rpcId = "36"
        optimize_for <: FileOptions_OptimizeMode:
            @json_tag = "optimizeFor"
            @rpcId = "9"
        php_class_prefix <: string:
            @description =:
                | Sets the php class prefix which is prepended to all php generated classes
                | from this .proto. Default is empty.
            @json_tag = "phpClassPrefix"
            @rpcId = "40"
        php_generic_services <: bool:
            @json_tag = "phpGenericServices"
            @rpcId = "42"
        php_metadata_namespace <: string:
            @description =:
                | Use this option to change the namespace of php generated metadata classes.
                | Default is empty. When this option is empty, the proto file name will be
                | used for determining the namespace.
            @json_tag = "phpMetadataNamespace"
            @rpcId = "44"
        php_namespace <: string:
            @description =:
                | Use this option to change the namespace of php generated classes. Default
                | is empty. When this option is empty, the package name will be used for
                | determining the namespace.
            @json_tag = "phpNamespace"
            @rpcId = "41"
        py_generic_services <: bool:
            @json_tag = "pyGenericServices"
            @rpcId = "18"
        ruby_package <: string:
            @description =:
                | Use this option to change the package of ruby generated classes. Default
                | is empty. When this option is not set, the package name will be used for
                | determining the ruby package.
            @json_tag = "rubyPackage"
            @rpcId = "45"
        swift_prefix <: string:
            @description =:
                | By default Swift generators will take the proto package and CamelCase it
                | replacing '.' with underscore and use that to prefix the types/symbols
                | defined. When this options is provided, they will use this value instead
                | to prefix the types/symbols defined.
            @json_tag = "swiftPrefix"
            @rpcId = "39"
        uninterpreted_option <: sequence of UninterpretedOption
    !enum FileOptions_OptimizeMode:
        CODE_SIZE: 2
        LITE_RUNTIME: 3
        SPEED: 1
    !type GeneratedCodeInfo:
        @description =:
            | Describes the relationship between generated code and its original source
            | file. A GeneratedCodeInfo message is associated with only one generated
            | source file, but may contain references to different source .proto files.
        @source_path = "google/protobuf/descriptor.proto"
        annotation <: sequence of GeneratedCodeInfo_Annotation
    !type GeneratedCodeInfo_Annotation:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        begin <: int:
            @description =:
                | Identifies the starting offset in bytes in the generated code
                | that relates to the identified object.
            @json_tag = "begin"
            @rpcId = "3"
        end <: int:
            @description =:
                | Identifies the ending offset in bytes in the generated code that
                | relates to the identified offset. The end offset should be one past
                | the last relevant byte (so the length of the text = end - begin).
            @json_tag = "end"
            @rpcId = "4"
        path <: sequence of int
        source_file <: string:
            @description =:
                | Identifies the filesystem path to the original source .proto.
            @json_tag = "sourceFile"
            @rpcId = "2"
    !type MessageOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        deprecated <: bool:
            @description =:
                | Is this message deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the message, or it will be completely ignored; in the very least,
                | this is a formalization for deprecating messages.
            @json_tag = "deprecated"
            @rpcId = "3"
        map_entry <: bool:
            @description =:
                | Whether the message is an automatically generated map entry type for the
                | maps field.
                | For maps fields:
                |     map<KeyType, ValueType> map_field = 1;
                | The parsed descriptor looks like:
                |     message MapFieldEntry {
                |         option map_entry = true;
                |         optional KeyType key = 1;
                |         optional ValueType value = 2;
                |     }
                |     repeated MapFieldEntry map_field = 1;
                | Implementations may choose not to generate the map_entry=true message, but
                | use a native map in the target language to hold the keys and values.
                | The reflection APIs in such implementations still need to work as
                | if the field is a repeated message field.
                | NOTE: Do not set the option in .proto files. Always use the maps syntax
                | instead. The option should only be implicitly set by the proto compiler
                | parser.
            @json_tag = "mapEntry"
            @rpcId = "7"
        message_set_wire_format <: bool:
            @description =:
                | Set true to use the old proto1 MessageSet wire format for extensions.
                | This is provided for backwards-compatibility with the MessageSet wire
                | format.  You should not use this for any other reason:  It's less
                | efficient, has fewer features, and is more complicated.
                | The message must be defined exactly as follows:
                |   message Foo {
                |     option message_set_wire_format = true;
                |     extensions 4 to max;
                |   }
                | Note that the message cannot have any defined fields; MessageSets only
                | have extensions.
                | All extensions of your type must be singular messages; e.g. they cannot
                | be int32s, enums, or repeated messages.
                | Because this is an option, the above two restrictions are not enforced by
                | the protocol compiler.
            @json_tag = "messageSetWireFormat"
            @rpcId = "1"
        no_standard_descriptor_accessor <: bool:
            @description =:
                | Disables the generation of the standard "descriptor()" accessor, which can
                | conflict with a field of the same name.  This is meant to make migration
                | from proto1 easier; new code should avoid fields named "descriptor".
            @json_tag = "noStandardDescriptorAccessor"
            @rpcId = "2"
        uninterpreted_option <: sequence of UninterpretedOption
    !type MethodDescriptorProto:
        @description =:
            | Describes a method of a service.
        @source_path = "google/protobuf/descriptor.proto"
        client_streaming <: bool:
            @description =:
                | Identifies if client streams multiple client messages
            @json_tag = "clientStreaming"
            @rpcId = "5"
        input_type <: string:
            @description =:
                | Input and output type names.  These are resolved in the same way as
                | FieldDescriptorProto.type_name, but must refer to a message type.
            @json_tag = "inputType"
            @rpcId = "2"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        options <: MethodOptions:
            @json_tag = "options"
            @rpcId = "4"
        output_type <: string:
            @json_tag = "outputType"
            @rpcId = "3"
        server_streaming <: bool:
            @description =:
                | Identifies if server streams multiple server messages
            @json_tag = "serverStreaming"
            @rpcId = "6"
    !type MethodOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        deprecated <: bool:
            @description =:
                | Is this method deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the method, or it will be completely ignored; in the very least,
                | this is a formalization for deprecating methods.
            @json_tag = "deprecated"
            @rpcId = "33"
        idempotency_level <: MethodOptions_IdempotencyLevel:
            @json_tag = "idempotencyLevel"
            @rpcId = "34"
        uninterpreted_option <: sequence of UninterpretedOption
    !enum MethodOptions_IdempotencyLevel:
        IDEMPOTENCY_UNKNOWN: 0
        IDEMPOTENT: 2
        NO_SIDE_EFFECTS: 1
    !type OneofDescriptorProto:
        @description =:
            | Describes a oneof.
        @source_path = "google/protobuf/descriptor.proto"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        options <: OneofOptions:
            @json_tag = "options"
            @rpcId = "2"
    !type OneofOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        uninterpreted_option <: sequence of UninterpretedOption
    !type ServiceDescriptorProto:
        @description =:
            | Describes a service.
        @source_path = "google/protobuf/descriptor.proto"
        method <: sequence of MethodDescriptorProto
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        options <: ServiceOptions:
            @json_tag = "options"
            @rpcId = "3"
    !type ServiceOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        deprecated <: bool:
            @description =:
                | Is this service deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the service, or it will be completely ignored; in the very least,
                | this is a formalization for deprecating services.
            @json_tag = "deprecated"
            @rpcId = "33"
        uninterpreted_option <: sequence of UninterpretedOption
    !type SourceCodeInfo:
        @description =:
            | Encapsulates information about the original source file from which a
            | FileDescriptorProto was generated.
        @source_path = "google/protobuf/descriptor.proto"
        location <: sequence of SourceCodeInfo_Location
    !type SourceCodeInfo_Location:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        leading_comments <: string:
            @description =:
                | If this SourceCodeInfo represents a complete declaration, these are any
                | comments appearing before and after the declaration which appear to be
                | attached to the declaration.
                | A series of line comments appearing on consecutive lines, with no other
                | tokens appearing on those lines, will be treated as a single comment.
                | leading_detached_comments will keep paragraphs of comments that appear
                | before (but not connected to) the current element. Each paragraph,
                | separated by empty lines, will be one comment element in the repeated
                | field.
                | Only the comment content is provided; comment markers (e.g. 
                |) are
                | stripped out.  For block comments, leading whitespace and an asterisk
                | will be stripped from the beginning of each line other than the first.
                | Newlines are included in the output.
                | Examples:
                |   optional int32 foo = 1;  
                | Comment attached to foo.
                |   
                | Comment attached to bar.
                |   optional int32 bar = 2;
                |   optional string baz = 3;
                |   
                | Comment attached to baz.
                |   
                | Another line attached to baz.
                |   
                | Comment attached to qux.
                |   
                |   
                | Another line attached to qux.
                |   optional double qux = 4;
                |   
                | Detached comment for corge. This is not leading or trailing comments
                |   
                | to qux or corge because there are blank lines separating it from
                |   
                | both.
                |   
                | Detached comment for corge paragraph 2.
                |   optional string corge = 5;
                |   /* Block comment attached
                |    * to corge.  Leading asterisks
                |    * will be removed. */
                |   /* Block comment attached to
                |    * grault. */
                |   optional int32 grault = 6;
                |   
                | ignored detached comments.
            @json_tag = "leadingComments"
            @rpcId = "3"
        leading_detached_comments <: sequence of string
        path <: sequence of int
        span <: sequence of int
        trailing_comments <: string:
            @json_tag = "trailingComments"
            @rpcId = "4"
    !type UninterpretedOption:
        @description =:
            | A message representing a option the parser does not recognize. This only
            | appears in options protos created by the compiler::Parser class.
            | DescriptorPool resolves these when building Descriptor objects. Therefore,
            | options protos in descriptor objects (e.g. returned by Descriptor::options(),
            | or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
            | in them.
        @source_path = "google/protobuf/descriptor.proto"
        aggregate_value <: string:
            @json_tag = "aggregateValue"
            @rpcId = "8"
        double_value <: float:
            @json_tag = "doubleValue"
            @rpcId = "6"
        identifier_value <: string:
            @description =:
                | The value of the uninterpreted option, in whatever type the tokenizer
                | identified it as during parsing. Exactly one of these should be set.
            @json_tag = "identifierValue"
            @rpcId = "3"
        name <: sequence of UninterpretedOption_NamePart
        negative_int_value <: int:
            @json_tag = "negativeIntValue"
            @rpcId = "5"
        positive_int_value <: int:
            @json_tag = "positiveIntValue"
            @rpcId = "4"
        string_value <: bytes:
            @json_tag = "stringValue"
            @rpcId = "7"
    !type UninterpretedOption_NamePart:
        @description =:
            | The name of the uninterpreted option.  Each string represents a segment in
            | a dot-separated name.  is_extension is true iff a segment represents an
            | extension (denoted with parentheses in options specs in .proto files).
            | E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
            | "foo.(bar.baz).qux".
        @source_path = "google/protobuf/descriptor.proto"
        is_extension <: bool:
            @json_tag = "isExtension"
            @rpcId = "2"
        name_part <: string:
            @json_tag = "namePart"
            @rpcId = "1"

grpc_testing:
    @package = "grpc_testing"
    !type EchoStatus:
        @description =:
            | A protobuf representation for grpc status. This is used by test
            | clients to specify a status that the server should attempt to return.
        @source_path = "tests/test/test.proto"
        code <: int:
            @json_tag = "code"
            @rpcId = "1"
        message <: string:
            @json_tag = "message"
            @rpcId = "2"
    !enum GrpclbRouteType:
        GRPCLB_ROUTE_TYPE_BACKEND: 2
        GRPCLB_ROUTE_TYPE_FALLBACK: 1
        GRPCLB_ROUTE_TYPE_UNKNOWN: 0
    !type Payload:
        @description =:
            | A block of data, to simply increase gRPC message size.
        @source_path = "tests/test/test.proto"
        body <: bytes:
            @description =:
                | Primary contents of payload.
            @json_tag = "body"
            @rpcId = "2"
        type <: PayloadType:
            @description =:
                | The type of data in body.
            @json_tag = "type"
            @rpcId = "1"
    !enum PayloadType:
        COMPRESSABLE: 0
        RANDOM: 2
        UNCOMPRESSABLE: 1
    !type ResponseParameters:
        @description =:
            | Configuration for a particular response.
        @source_path = "tests/test/test.proto"
        interval_us <: int:
            @description =:
                | Desired interval between consecutive responses in the response stream in
                | microseconds.
            @json_tag = "intervalUs"
            @rpcId = "2"
        size <: int:
            @description =:
                | Desired payload sizes in responses from the server.
                | If response_type is COMPRESSABLE, this denotes the size before compression.
            @json_tag = "size"
            @rpcId = "1"
    !type SimpleRequest:
        @description =:
            | Unary request.
        @source_path = "tests/test/test.proto"
        fill_grpclb_route_type <: bool:
            @description =:
                | Whether SimpleResponse should include grpclb_route_type.
            @json_tag = "fillGrpclbRouteType"
            @rpcId = "10"
        fill_oauth_scope <: bool:
            @description =:
                | Whether SimpleResponse should include OAuth scope.
            @json_tag = "fillOauthScope"
            @rpcId = "5"
        fill_server_id <: bool:
            @description =:
                | Whether SimpleResponse should include server_id.
            @json_tag = "fillServerId"
            @rpcId = "9"
        fill_username <: bool:
            @description =:
                | Whether SimpleResponse should include username.
            @json_tag = "fillUsername"
            @rpcId = "4"
        payload <: Payload:
            @description =:
                | Optional input payload sent along with the request.
            @json_tag = "payload"
            @rpcId = "3"
        response_size <: int:
            @description =:
                | Desired payload size in the response from the server.
                | If response_type is COMPRESSABLE, this denotes the size before compression.
            @json_tag = "responseSize"
            @rpcId = "2"
        response_status <: EchoStatus:
            @description =:
                | Whether server should return a given status
            @json_tag = "responseStatus"
            @rpcId = "7"
        response_type <: PayloadType:
            @description =:
                | Desired payload type in the response from the server.
                | If response_type is RANDOM, server randomly chooses one from other formats.
            @json_tag = "responseType"
            @rpcId = "1"
    !type SimpleResponse:
        @description =:
            | Unary response, as configured by the request.
        @source_path = "tests/test/test.proto"
        grpclb_route_type <: GrpclbRouteType:
            @description =:
                | gRPCLB Path.
            @json_tag = "grpclbRouteType"
            @rpcId = "5"
        oauth_scope <: string:
            @description =:
                | OAuth scope.
            @json_tag = "oauthScope"
            @rpcId = "3"
        payload <: Payload:
            @description =:
                | Payload to increase message size.
            @json_tag = "payload"
            @rpcId = "1"
        server_id <: string:
            @description =:
                | Server ID. This must be unique among different server instances,
                | but the same across all RPC's made to a particular server instance.
            @json_tag = "serverId"
            @rpcId = "4"
        username <: string:
            @description =:
                | The user the request came from, for verifying authentication was
                | successful when the client expected it.
            @json_tag = "username"
            @rpcId = "2"
    !type StreamingInputCallRequest:
        @description =:
            | Client-streaming request.
        @source_path = "tests/test/test.proto"
        payload <: Payload:
            @description =:
                | Optional input payload sent along with the request.
            @json_tag = "payload"
            @rpcId = "1"
    !type StreamingInputCallResponse:
        @description =:
            | Client-streaming response.
        @source_path = "tests/test/test.proto"
        aggregated_payload_size <: int:
            @description =:
                | Aggregated size of payloads received from the client.
            @json_tag = "aggregatedPayloadSize"
            @rpcId = "1"
    !type StreamingOutputCallRequest:
        @description =:
            | Server-streaming request.
        @source_path = "tests/test/test.proto"
        payload <: Payload:
            @description =:
                | Optional input payload sent along with the request.
            @json_tag = "payload"
            @rpcId = "3"
        response_parameters <: sequence of ResponseParameters
        response_status <: EchoStatus:
            @description =:
                | Whether server should return a given status
            @json_tag = "responseStatus"
            @rpcId = "7"
        response_type <: PayloadType:
            @description =:
                | Desired payload type in the response from the server.
                | If response_type is RANDOM, the payload from each response in the stream
                | might be of different types. This is to simulate a mixed type of payload
                | stream.
            @json_tag = "responseType"
            @rpcId = "1"
    !type StreamingOutputCallResponse:
        @description =:
            | Server-streaming response, as configured by the request and parameters.
        @source_path = "tests/test/test.proto"
        payload <: Payload:
            @description =:
                | Payload to increase response size.
            @json_tag = "payload"
            @rpcId = "1"

