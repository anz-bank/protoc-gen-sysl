Grpc:
  !view start(module <: sysl.TemplateInput) -> sysl.TemplateResult:
    module -> (:
      $! {'//   THIS IS AUTOGENERATED BY sysl   //'}
      $! {'syntax = "proto3";'}
      let packageName = "option go_package = " + "\"grpc\";"
      $! {packageName}
      $! {'package grpc;'}
      $! {"\n"}

      let apps = module.Apps -> <set of string> (app:
        let types = GenTypes(app)
        let out = if app.name == "Bff" then writeEndpoints(app, types) else ""
      )
    )

  !view writeEndpoints(app <: sysl.App, types <: set of Type) -> string:
    app -> (:
        $! service {app.name + " {"}
        let eps = app.endpoints -> <set of string> (ep:
          out = endpointToService(ep, types, app.name)
        )
        let methods = eps flatten(.out.methods) -> (meth:
          $! {meth}
        )
        $! }

        let parameters = eps flatten(.out.params) -> (params:
          $! {params.out}
        )
        let response = eps flatten(.out.response) -> (response:
          $! {response.out}
        )
    )  
  
  !view GenTypes(app <: sysl.App) -> string:
    app -> (:
      let grpcTypes = Join(GrpcMessageTypes(app.types, app.name) flatten(.out), "\n\n")
      $! {grpcTypes}
      let appAliases = app.alias -> <set of string> (alias:
        let start = 'message ' + app.name + alias.key +' {'
        let end = '}'
        out = start + "\n" + " string" + " alias" + alias.type + ' = ' + "1" + ';' + "\n" + end
      )
      $! {Join(appAliases flatten(.out), "\n")}
      type = app.types
    )

  !view GrpcMessageTypes(types <: set of Type, app <: string) -> sequence of string:
    types -> (type:
        let start = 'message ' + app + type.key +' {'
        let end = '}'
        out = start + "\n" +Join(GrpcFields(type.fields, app) flatten(.out), "\n") + "\n" + end
    )

  !view GrpcFields(fields <: set of Type, app <: string) -> sequence of string:
    fields -> (field:
      out = ' ' + GrpcType(field, app).out + ' ' + Replace(field.key, "-", "", -1) + ' = ' + field.attrs.rpcId + ';'
    )

  !view GrpcType(t <: sysl.Type, app <: string) -> string:
    t -> (:
      let typeName = if t.type ==:
        'primitive' => if t.primitive ==:
          'DECIMAL' => 'double'
          'INT' => 'int64'
          'FLOAT' => 'double'
          'STRING' => 'string'
          'STRING_8' => 'string'
          'BOOL' => 'bool'
          'DATE' => 'string'
          'DATETIME' => 'string'
        'sequence' => 'repeated ' + GrpcType(t.sequence, app).out
        else app + t.type_ref
      out = typeName
    )

  !view endpointToService(ep <: sysl.Endpoint, grpcTypes <: sequence of string, app <: string) -> sequence of string:
    ep -> (:
        let returnTypes = ep.ret where(.key == "ok") -> <sequence of string>(a:
           out = a.value
        )
        let returnName = Join(returnTypes flatten(.out),"")
        let method = Title(ToLower(ep.method))
        let withArg = if MatchString("\\{\\p{L}+\\}$", ep.path) && Contains("POST", ToUpper(method)) then "WithArg" else ""
        let getList = if MatchString("[\\p{L}\\p{N}]$", ep.path) && Contains("GET", ToUpper(method)) then "List" else ""

        let Method = endpointMethod(ep).out + withArg + getList
        let parameterName =  Method + "Request"
        let responseName =  Method + "Response"
        response = wrapResponseParams(ep, returnName, responseName, app)

        methods = " rpc " + Method + "(" + parameterName + ") returns (" + responseName + ") {}"
        params = wrapRequestParams(ep, parameterName, app)
    )

  !view wrapRequestParams(ep <: sysl.Endpoint, parameterName <: string, app <: string)->string:
    ep -> (:
      let qParam = getQueryParams(ep, app).returnParams -> <sequence of QueryParams> (p:
        let attrs = ep.attrs where(.key == p.name + "_rpcId") -> <sequence of string>(a:
           out = a.value
        )
        out = " " +p.type + " " + "req" + p.name + " = " + Join(attrs flatten(.out),"") + ";"
      )
      let pParam = getPathParams(ep, app).returnParams -> <sequence of PathParams> (p:
        let attrs = ep.attrs where(.key == p.name + "_rpcId") -> <sequence of string>(a:
           out = a.value
        )
        out = " " +p.type + " " + "req" + p.name + " = " + Join(attrs flatten(.out),"") + ";"
      )
      out = "message " + parameterName +  " {\n " + Join(qParam flatten(.out), "\n") + "\n" + Join(pParam flatten(.out), "\n") + "\n}"
    )

  !view wrapResponseParams(ep <: sysl.Endpoint, returnName <: string, parameterName <: string, app <: string)->string:
    ep -> (:
        let attrs = ep.attrs where(.key == Replace(returnName, ".", "", -1) + "_rpcId") -> <sequence of string>(a:
          out = a.value
        )
        let fieldType = if Split(returnName,".") count > 1 then Replace(returnName, ".", "", -1) else app + returnName  
        let fieldName = "res" + Replace(returnName, ".", "", -1)
        let typeString = " " +fieldType + " " + fieldName + " = " + Join(attrs flatten(.out),"") + ";"
        out = "message " + parameterName +  "{\n " + typeString + "\n}"
    )

  !view endpointService(ep <: sysl.Endpoint)-> sequence of string:
    ep ->(:
      let service = ep.path -> <sequence of string>(p:
          out = Replace(p, "/", "", -1)
      )
      out = service.out
    )

  !view endpointMethod(ep <: sysl.Endpoint) -> sequence of string:
    ep -> <sequence of string> (:
      let terms = ep.pathvars -> <set of string> (:
        out = "{" + .name + "}"
      )
      let pathVars = terms flatten(.out)
      let path = Split(ep.path, "/")
      let method = Title(ToLower(ep.method))

      let methodPostfix = path -> <set of string> (p:
        let postfix = if p in pathVars then "" else p
        out = Title(ToLower(postfix))
      )
      out = method + Join(methodPostfix flatten(.out), "")
    )

  !view getQueryParams(ep <: sysl.Endpoint, app <: string) -> ReturnParams:
    ep -> (:
      let queryParams = ep.queryvars -> <sequence of QueryParams> (param:
        name = Replace(param.name, "-", "", -1)
        type = GrpcType(param, app).out
      )
      returnParams = queryParams
    )

  !view getPathParams(ep <: sysl.Endpoint, app <: string) -> ReturnParams:
    ep -> (:
      let pathParams = ep.pathvars -> <sequence of PathParams> (param:
        name = Replace(param.name, "-", "", -1)
        type = GrpcType(param, app).out
      )
      returnParams = pathParams
    )  
